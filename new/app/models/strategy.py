"""
Trading strategy models for signal generation.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Any
import json
from datetime import datetime
from pathlib import Path

import numpy as np
import pandas as pd


class SignalType(Enum):
    """Enum representing trading signal types."""
    LONG = "LONG"
    NEUTRAL = "NEUTRAL"
    SHORT = "SHORT"
    
    def __str__(self) -> str:
        return self.value


@dataclass
class Signal:
    """A trading signal generated by a strategy."""
    symbol: str
    strategy_id: str
    signal_type: SignalType
    timestamp: datetime
    strength: float = 0.0  # 0.0 to 1.0
    params: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> dict:
        """Convert signal to dictionary for serialization."""
        return {
            'symbol': self.symbol,
            'strategy_id': self.strategy_id,
            'signal_type': self.signal_type.value,
            'timestamp': self.timestamp.isoformat(),
            'strength': self.strength,
            'params': self.params
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'Signal':
        """Create a signal from a dictionary."""
        return cls(
            symbol=data['symbol'],
            strategy_id=data['strategy_id'],
            signal_type=SignalType(data['signal_type']),
            timestamp=datetime.fromisoformat(data['timestamp']),
            strength=data['strength'],
            params=data.get('params')
        )


class Strategy(ABC):
    """Abstract base class for all trading strategies."""
    
    def __init__(self, strategy_id: str, name: str, description: str = ""):
        """Initialize a strategy.
        
        Args:
            strategy_id: Unique identifier for the strategy
            name: Display name for the strategy
            description: Description of how the strategy works
        """
        self.strategy_id = strategy_id
        self.name = name
        self.description = description
        self.parameters: Dict[str, Any] = {}
        
    @abstractmethod
    def generate_signal(self, symbol: str, data: pd.DataFrame) -> Signal:
        """Generate a trading signal based on the input data.
        
        Args:
            symbol: The trading symbol to analyze
            data: DataFrame with OHLCV data
            
        Returns:
            Signal: The generated trading signal
        """
        pass
        
    def set_parameter(self, key: str, value: Any):
        """Set a strategy parameter.
        
        Args:
            key: Parameter name
            value: Parameter value
        """
        self.parameters[key] = value
        
    def get_parameter(self, key: str, default: Any = None) -> Any:
        """Get a strategy parameter.
        
        Args:
            key: Parameter name
            default: Default value if parameter doesn't exist
            
        Returns:
            Any: The parameter value
        """
        return self.parameters.get(key, default)
        
    def to_dict(self) -> dict:
        """Convert strategy to dictionary for serialization."""
        return {
            'strategy_id': self.strategy_id,
            'name': self.name,
            'description': self.description,
            'parameters': self.parameters,
            'type': self.__class__.__name__
        }


class EMAStrategy(Strategy):
    """Trading strategy based on Exponential Moving Averages."""
    
    def __init__(self):
        """Initialize the EMA strategy with default parameters."""
        super().__init__(
            "ema_crossover",
            "EMA Crossover",
            "Generates signals based on crossovers between fast and slow EMAs"
        )
        self.parameters = {
            'fast_period': 12,
            'slow_period': 26
        }
        
    def generate_signal(self, symbol: str, data: pd.DataFrame) -> Signal:
        """Generate a trading signal based on EMA crossovers.
        
        Args:
            symbol: The trading symbol to analyze
            data: DataFrame with OHLCV data
            
        Returns:
            Signal: The generated trading signal
        """
        fast_period = self.parameters['fast_period']
        slow_period = self.parameters['slow_period']
        
        # Calculate EMAs
        fast_ema = data['close'].ewm(span=fast_period, adjust=False).mean()
        slow_ema = data['close'].ewm(span=slow_period, adjust=False).mean()
        
        # Determine signal type
        if fast_ema.iloc[-1] > slow_ema.iloc[-1] and fast_ema.iloc[-2] <= slow_ema.iloc[-2]:
            signal_type = SignalType.LONG
            strength = 1.0
        elif fast_ema.iloc[-1] < slow_ema.iloc[-1] and fast_ema.iloc[-2] >= slow_ema.iloc[-2]:
            signal_type = SignalType.SHORT
            strength = 1.0
        else:
            # Calculate relative position between EMAs for neutral signals
            diff = fast_ema.iloc[-1] - slow_ema.iloc[-1]
            if diff > 0:
                signal_type = SignalType.LONG
                # Normalize strength based on recent crossing history
                strength = min(diff / data['close'].iloc[-1] * 100, 1.0)
            elif diff < 0:
                signal_type = SignalType.SHORT
                # Normalize strength based on recent crossing history
                strength = min(abs(diff) / data['close'].iloc[-1] * 100, 1.0)
            else:
                signal_type = SignalType.NEUTRAL
                strength = 0.0
                
        return Signal(
            symbol=symbol,
            strategy_id=self.strategy_id,
            signal_type=signal_type,
            timestamp=datetime.now(),
            strength=strength,
            params={
                'fast_ema': fast_ema.iloc[-1],
                'slow_ema': slow_ema.iloc[-1]
            }
        )


class RSIStrategy(Strategy):
    """Trading strategy based on Relative Strength Index."""
    
    def __init__(self):
        """Initialize the RSI strategy with default parameters."""
        super().__init__(
            "rsi",
            "RSI",
            "Generates signals based on RSI overbought/oversold conditions"
        )
        self.parameters = {
            'period': 14,
            'overbought': 70,
            'oversold': 30
        }
        
    def generate_signal(self, symbol: str, data: pd.DataFrame) -> Signal:
        """Generate a trading signal based on RSI values.
        
        Args:
            symbol: The trading symbol to analyze
            data: DataFrame with OHLCV data
            
        Returns:
            Signal: The generated trading signal
        """
        period = self.parameters['period']
        overbought = self.parameters['overbought']
        oversold = self.parameters['oversold']
        
        # Calculate RSI
        delta = data['close'].diff()
        gain = delta.where(delta > 0, 0).rolling(window=period).mean()
        loss = -delta.where(delta < 0, 0).rolling(window=period).mean()
        
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        
        current_rsi = rsi.iloc[-1]
        
        # Determine signal type
        if current_rsi <= oversold:
            signal_type = SignalType.LONG
            # Calculate strength based on how oversold
            strength = min((oversold - current_rsi) / oversold, 1.0)
        elif current_rsi >= overbought:
            signal_type = SignalType.SHORT
            # Calculate strength based on how overbought
            strength = min((current_rsi - overbought) / (100 - overbought), 1.0)
        else:
            # Neutral zone - determine slight bias based on position in the range
            mid_point = (overbought + oversold) / 2
            if current_rsi > mid_point:
                signal_type = SignalType.SHORT
                # Weaker signal in neutral zone
                strength = (current_rsi - mid_point) / (overbought - mid_point) * 0.5
            elif current_rsi < mid_point:
                signal_type = SignalType.LONG
                # Weaker signal in neutral zone
                strength = (mid_point - current_rsi) / (mid_point - oversold) * 0.5
            else:
                signal_type = SignalType.NEUTRAL
                strength = 0.0
                
        return Signal(
            symbol=symbol,
            strategy_id=self.strategy_id,
            signal_type=signal_type,
            timestamp=datetime.now(),
            strength=strength,
            params={'rsi': current_rsi}
        )


class MACDStrategy(Strategy):
    """Trading strategy based on Moving Average Convergence Divergence."""
    
    def __init__(self):
        """Initialize the MACD strategy with default parameters."""
        super().__init__(
            "macd",
            "MACD",
            "Generates signals based on MACD line, signal line, and histogram"
        )
        self.parameters = {
            'fast_period': 12,
            'slow_period': 26,
            'signal_period': 9
        }
        
    def generate_signal(self, symbol: str, data: pd.DataFrame) -> Signal:
        """Generate a trading signal based on MACD values.
        
        Args:
            symbol: The trading symbol to analyze
            data: DataFrame with OHLCV data
            
        Returns:
            Signal: The generated trading signal
        """
        fast = self.parameters['fast_period']
        slow = self.parameters['slow_period']
        signal_period = self.parameters['signal_period']
        
        # Calculate MACD components
        fast_ema = data['close'].ewm(span=fast, adjust=False).mean()
        slow_ema = data['close'].ewm(span=slow, adjust=False).mean()
        
        macd_line = fast_ema - slow_ema
        signal_line = macd_line.ewm(span=signal_period, adjust=False).mean()
        histogram = macd_line - signal_line
        
        # Current values
        current_macd = macd_line.iloc[-1]
        current_signal = signal_line.iloc[-1]
        current_hist = histogram.iloc[-1]
        prev_hist = histogram.iloc[-2] if len(histogram) > 1 else 0
        
        # Determine signal type
        if current_macd > current_signal:
            # Bullish case
            signal_type = SignalType.LONG
            # Strength depends on histogram value and if crossing just happened
            if current_hist > 0 and prev_hist <= 0:
                # Fresh crossover - strongest signal
                strength = 1.0
            else:
                # Scale strength by histogram value relative to recent range
                hist_range = histogram.abs().max()
                strength = min(current_hist / hist_range if hist_range > 0 else 0.5, 1.0)
        elif current_macd < current_signal:
            # Bearish case
            signal_type = SignalType.SHORT
            # Strength depends on histogram value and if crossing just happened
            if current_hist < 0 and prev_hist >= 0:
                # Fresh crossover - strongest signal
                strength = 1.0
            else:
                # Scale strength by histogram value relative to recent range
                hist_range = histogram.abs().max()
                strength = min(abs(current_hist) / hist_range if hist_range > 0 else 0.5, 1.0)
        else:
            # Equal values - neutral
            signal_type = SignalType.NEUTRAL
            strength = 0.0
            
        return Signal(
            symbol=symbol,
            strategy_id=self.strategy_id,
            signal_type=signal_type,
            timestamp=datetime.now(),
            strength=strength,
            params={
                'macd': current_macd,
                'signal': current_signal,
                'histogram': current_hist
            }
        )


class StrategyRegistry:
    """Registry of available trading strategies."""
    
    _strategies: Dict[str, Strategy] = {
        "ema_crossover": EMAStrategy(),
        "rsi": RSIStrategy(),
        "macd": MACDStrategy()
    }
    
    @classmethod
    def get_strategy(cls, strategy_id: str) -> Optional[Strategy]:
        """Get a strategy by ID."""
        return cls._strategies.get(strategy_id)
        
    @classmethod
    def get_all_strategies(cls) -> List[Strategy]:
        """Get all registered strategies."""
        return list(cls._strategies.values())
        
    @classmethod
    def register_strategy(cls, strategy: Strategy) -> bool:
        """Register a new strategy.
        
        Args:
            strategy: The strategy instance to register
            
        Returns:
            bool: True if registered, False if ID already exists
        """
        if strategy.strategy_id in cls._strategies:
            return False
            
        cls._strategies[strategy.strategy_id] = strategy
        return True
